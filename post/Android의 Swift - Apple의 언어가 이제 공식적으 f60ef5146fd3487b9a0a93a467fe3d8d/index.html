<!DOCTYPE html><html lang="ko" data-astro-cid-ztig7rse> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>상세</title><link rel="icon" href="/pages/favicon.svg" type="image/svg+xml"><link rel="icon" href="/pages/favicon-32x32.png" sizes="32x32"><link rel="apple-touch-icon" href="/pages/apple-touch-icon.png" sizes="180x180"><style>:root{color-scheme:light dark}body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}.wrap[data-astro-cid-ztig7rse]{max-width:860px;margin:0 auto;padding:20px}.topbar[data-astro-cid-ztig7rse]{position:sticky;top:0;backdrop-filter:blur(6px);background:color-mix(in oklab,canvas,transparent 35%);border-bottom:1px solid color-mix(in oklab,canvastext,transparent 90%);z-index:10}.topbar[data-astro-cid-ztig7rse] .inner[data-astro-cid-ztig7rse]{display:flex;align-items:center;gap:8px;padding:10px 20px;max-width:860px;margin:0 auto}.btn[data-astro-cid-ztig7rse]{appearance:none;border:1px solid color-mix(in oklab,canvastext,transparent 85%);background:transparent;color:inherit;border-radius:10px;padding:8px 12px;cursor:pointer;font-size:14px}.btn[data-astro-cid-ztig7rse].primary{background:#111827;color:#fff;border-color:#111827}@media (prefers-color-scheme: dark){.btn[data-astro-cid-ztig7rse].primary{background:#e5e7eb;color:#111827;border-color:#e5e7eb}}.hero[data-astro-cid-ztig7rse]{margin:14px 0 8px;display:none}.hero[data-astro-cid-ztig7rse] img[data-astro-cid-ztig7rse]{width:100%;height:auto;border-radius:12px;display:block;background:#f3f4f6}article[data-astro-cid-ztig7rse]{line-height:1.72;font-size:16px}article[data-astro-cid-ztig7rse] :is(h1,h2,h3)[data-astro-cid-ztig7rse]{line-height:1.25;margin:24px 0 10px}article[data-astro-cid-ztig7rse] h1[data-astro-cid-ztig7rse]{font-size:28px}article[data-astro-cid-ztig7rse] h2[data-astro-cid-ztig7rse]{font-size:22px}article[data-astro-cid-ztig7rse] h3[data-astro-cid-ztig7rse]{font-size:18px}article[data-astro-cid-ztig7rse] p[data-astro-cid-ztig7rse]{margin:10px 0}article[data-astro-cid-ztig7rse] img[data-astro-cid-ztig7rse]{max-width:100%;height:auto;border-radius:8px;background:#f3f4f6}article[data-astro-cid-ztig7rse] pre[data-astro-cid-ztig7rse]{overflow:auto;padding:14px;border:1px solid color-mix(in oklab,canvastext,transparent 90%);border-radius:10px;background:color-mix(in oklab,canvastext,transparent 96%)}article[data-astro-cid-ztig7rse] code[data-astro-cid-ztig7rse]:not(pre code){background:color-mix(in oklab,canvastext,transparent 94%);padding:2px 6px;border-radius:6px}article[data-astro-cid-ztig7rse] blockquote[data-astro-cid-ztig7rse]{border-left:3px solid #9CA3AF;margin:8px 0;padding:4px 12px;color:#6b7280}.actions[data-astro-cid-ztig7rse]{display:flex;gap:8px;flex-wrap:wrap;margin:12px 0 18px}
</style></head> <body class="container" style="padding:24px;max-width:900px" data-astro-cid-ztig7rse> <div class="topbar" data-astro-cid-ztig7rse> <div class="inner" data-astro-cid-ztig7rse> <a class="btn" href="/pages/" aria-label="홈으로" data-astro-cid-ztig7rse>← 홈</a> <a class="btn" id="source" href="#" target="_blank" rel="noopener" style="display:none" data-astro-cid-ztig7rse>원문 보기</a> </div> </div> <div class="wrap" data-astro-cid-ztig7rse> <h1 style="margin:10px 0 6px" data-astro-cid-ztig7rse></h1> <div class="hero" id="hero" data-astro-cid-ztig7rse><img alt="" id="heroImg" loading="eager" data-astro-cid-ztig7rse></div> <div class="actions" data-astro-cid-ztig7rse> <a class="btn primary" id="ctaSource" href="#" target="_blank" rel="noopener" style="display:none" data-astro-cid-ztig7rse>원문 바로가기</a> </div> <article data-astro-cid-ztig7rse> <h1 id="android의-swift---apple의-언어가-이제-공식적으로-android를-지원">Android의 Swift - Apple의 언어가 이제 공식적으로 Android를 지원</h1>
<p>발견일: 2025/07/07
원문 URL: <a href="https://medium.com/@sharma-deepak/swift-on-android-one-language-to-rule-them-all-cd75d9d37328">https://medium.com/@sharma-deepak/swift-on-android-one-language-to-rule-them-all-cd75d9d37328</a>
분류: 인사이트
원문 Source: 🔗medium
즐겨찾기: No</p>
<p><a href="https://miro.medium.com/v2/da:true/resize:fit:1200/0*nxoK--d7Xo4PEhyO"></a></p>
<h2 id="breaking-swift-android-working-group-makes-cross-platform-development-reality">Breaking: Swift Android Working Group makes cross-platform development reality</h2>
<p>속보: Swift Android Working Group이 크로스 플랫폼 개발을 현실로 만듭니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fill:32:32/1*omWVYTqY2zP1HlFSFiCNsQ@2x.jpeg" alt=""></p>
<p><a href="https://medium.com/@sharma-deepak?source=post_page---byline--cd75d9d37328---------------------------------------">Deepak Sharma</a></p>
<p>Follow</p>
<p>7 min read</p>
<p>Jun 28, 2025</p>
<p>360</p>
<p>4</p>
<p><a href="https://medium.com/plans?dimension=post_audio_button&#x26;postId=cd75d9d37328&#x26;source=upgrade_membership---post_audio_button-----------------------------------------">Listen</a></p>
<p>Share</p>
<p>More</p>
<p>Press enter or click to view image in full size</p>
<p><a href="https://miro.medium.com/v2/resize:fit:700/0*nxoK--d7Xo4PEhyO"></a></p>
<p>Photo by <a href="https://unsplash.com/@jstrippa?utm_source=medium&#x26;utm_medium=referral">James Harrison</a> on <a href="https://unsplash.com/?utm_source=medium&#x26;utm_medium=referral">Unsplash</a>
님이 촬영 한 사진 <a href="https://unsplash.com/@jstrippa?utm_source=medium&#x26;utm_medium=referral">제임스 해리슨</a> <a href="https://unsplash.com/?utm_source=medium&#x26;utm_medium=referral">on Unsplash</a></p>
<p><strong>Not a Medium member?</strong> <a href="https://medium.com/@sharma-deepak/swift-on-android-one-language-to-rule-them-all-cd75d9d37328?sk=e61e407e3b0b7360790a2d6e94bd322e"><strong>Use this link to read the blog for free👇!</strong></a>
<strong>미디엄 회원이 아니신가요?<a href="https://medium.com/@sharma-deepak/swift-on-android-one-language-to-rule-them-all-cd75d9d37328?sk=e61e407e3b0b7360790a2d6e94bd322e">이 링크를 사용하여 블로그를 무료로👇 읽어보세요!</a></strong>
<em>If it resonated, a clap or comment keeps the spark alive.</em>
<em>공감을 불러일으켰다면 박수나 댓글이 불꽃을 계속 유지합니다.</em></p>
<p>If you had told a mobile developer five years ago that Swift would officially support Android, they’d probably laugh. Apple’s entire ecosystem has long been seen as a walled garden polished, fast, and strictly theirs.
5년 전 모바일 개발자에게 Swift가 공식적으로 Android를 지원할 것이라고 말했다면 아마도 웃었을 것입니다. Apple의 전체 생태계는 오랫동안 세련되고 빠르며 엄격하게 그들만의 벽으로 둘러싸인 정원으로 여겨져 왔습니다.</p>
<p><strong>Fast forward to mid-2025 and suddenly, Apple’s primary language is going cross-platform in a major way.</strong>
<strong>2025년 중반으로 빠르게 넘어가면 갑자기 Apple의 기본 언어가 대대적인 방식으로 크로스 플랫폼으로 전환되고 있습니다.</strong></p>
<p>A newly launched <strong>Swift Android Working Group</strong> is now working to make Android an officially supported target for Swift. This isn’t a hack or workaround it’s <strong>official, native, and game-changing</strong>.
새로 출범한 <strong>Swift Android Working Group</strong>은 이제 Android를 Swift의 공식 지원 대상으로 만들기 위해 노력하고 있습니다. 이것은 해킹이나 해결 방법이 아니라 <strong>공식적이고 기본적이며 판도를 바꾸는 것입니다</strong>.</p>
<p>Let that sink in: <strong>Swift. Android. Official. Native.</strong>
스위프트를 스위프트로 받아들이<strong>세요. 로봇. 관. 원주민.</strong></p>
<p>This is the biggest cross-platform shift in mobile development since Flutter and Kotlin Multiplatform made headlines. Here’s everything you need to know.
이는 Flutter와 Kotlin Multiplatform이 헤드라인을 장식한 이후 모바일 개발에서 가장 큰 크로스 플랫폼 전환입니다. 여기에 당신이 알아야 할 모든 것이 있습니다.</p>
<p>Press enter or click to view image in full size</p>
<p><img src="https://miro.medium.com/v2/resize:fit:700/1*yTS9Q34noM9OaMFfucHSNw.png" alt=""></p>
<p>And no, this isn’t just about Swift “running” on Android — it’s about redefining how we build mobile apps, how we structure dev teams, and how code gets shared between platforms.
그리고 아니요, 이것은 단순히 Android에서 Swift를 “실행”하는 것에 관한 것이 아니라 모바일 앱을 구축하는 방법, 개발 팀을 구성하는 방법, 플랫폼 간에 코드를 공유하는 방법을 재정의하는 것입니다.</p>
<p>Let’s break it all down.
모든 것을 분석해 봅시다.</p>
<h1 id="why-this-changes-everything">Why This Changes Everything</h1>
<p>이것이 모든 것을 바꾸는 이유</p>
<h1 id="the-end-of-the-ios-android-war">The End of the iOS-Android War</h1>
<p>iOS-Android 전쟁의 종말</p>
<p>For years, mobile teams have been stuck:
수년 동안 모바일 팀은 다음과 같은 상황에 처해 있습니다.</p>
<ul>
<li><strong>iOS developers:</strong> Master Swift, build amazing apps, but limited to Apple’s ecosystem
<strong>iOS 개발자:</strong> Swift를 마스터하고 놀라운 앱을 구축하지만 Apple의 생태계로 제한됩니다.</li>
<li><strong>Android developers:</strong> Excel with Kotlin, but can’t share code with iOS
<strong>Android 개발자:</strong> Kotlin을 사용하여 Excel을 사용할 수 있지만 iOS와 코드를 공유할 수 없습니다.</li>
<li><strong>Companies:</strong> Pay double to maintain two completely separate codebases
<strong>회사:</strong> 두 개의 완전히 분리된 코드베이스를 유지하기 위해 두 배를 지불하십시오.</li>
</ul>
<p><strong>Swift on Android breaks this cycle.</strong>
<strong>Android의 Swift는 이 순환을 깨뜨립니다.</strong></p>
<h1 id="whats-different-this-time">What’s Different This Time</h1>
<p>이번에는 무엇이 다른지</p>
<p>Unlike previous cross-platform attempts, this isn’t about compromise:
이전의 크로스 플랫폼 시도와 달리 이것은 타협에 관한 것이 아닙니다.</p>
<ul>
<li><strong>Performance:</strong> Native compilation, no interpretation overhead
<strong>공연:</strong> 네이티브 컴파일, 해석 오버헤드 없음</li>
<li><strong>Ecosystem:</strong> Full access to Android APIs through JNI
<strong>생태계:</strong> JNI를 통한 Android API에 대한 전체 액세스</li>
<li><strong>Tooling:</strong> Official Swift.org backing, not a third-party hack
<strong>압형:</strong> 타사 해킹이 아닌 공식 Swift.org 지원</li>
<li><strong>Future-proof:</strong> Apple’s own language expanding beyond their walls
<strong>미래 보장:</strong> 벽 너머로 확장되는 Apple의 자체 언어</li>
</ul>
<h1 id="why-this-news-matters-more-than-you-think">Why This News Matters More Than You Think</h1>
<p>이 소식이 생각보다 중요한 이유</p>
<p>Because it challenges <em>everything</em> we thought was “normal” in mobile dev:
모바일 개발에서 “정상적”이라고 생각했던 <em>모든 것에</em> 도전하기 때문입니다.</p>
<ul>
<li><strong>Historic Shift:</strong> Apple opening the door to Android (even indirectly) is unprecedented. It’s no longer an “Apple-only” world.
<strong>역사적인 변화:</strong> Apple이 Android에 대한 문을 (간접적으로도) 여는 것은 전례가 없는 일입니다. 더 이상 “애플만의” 세상이 아닙니다.</li>
<li><strong>Breaking the Tug-of-War:</strong> Cross-platform frameworks like Flutter and KMP tried to bridge iOS and Android. Now the language itself bridges them. Teams won’t have to pick “Swift vs Kotlin” as zealously.
<strong>줄다리</strong>기 깨기: Flutter 및 KMP와 같은 크로스 플랫폼 프레임워크는 iOS와 Android를 연결하려고 시도했습니다. 이제 언어 자체가 그것들을 연결해 줍니다. 팀은 “Swift vs Kotlin”을 열성적으로 선택할 필요가 없습니다.</li>
<li><strong>Faster, Cheaper, Cleaner:</strong> Startups and indie teams could build once, deploy twice. Share your networking, models, and data formatting code only platform-specific UI (Jetpack Compose vs SwiftUI) needs rewriting.
<strong>더 빠르고, 저렴하고, 더 깨끗합니다.</strong> 스타트업과 인디 팀은 한 번 구축하고 두 번 배포할 수 있습니다. 네트워킹, 모델 및 데이터 형식 코드 공유 플랫폼별 UI(Jetpack Compose 대 SwiftUI)만 다시 작성해야 합니다.</li>
<li><strong>Full-Stack Swift:</strong> Swift already powers server-side (e.g. Vapor) and even WebAssembly apps. With Android in play, the “full-stack Swift” vision (backend + iOS + Android) moves closer to reality.
<strong>풀스택 스위프트:</strong> Swift는 이미 서버 측(예: Vapor) 및 WebAssembly 앱을 지원합니다. Android가 작동하면서 “풀스택 Swift” 비전(백엔드 + iOS + Android)이 현실에 더 가까워졌습니다.</li>
<li><strong>Languages, Not Platforms, as Power:</strong> This signals a deeper trend: engineers favor the tools they love over vendor lock-in. If UI frameworks like Flutter bridged views, and KMP bridged logic, <em>Swift on Android</em> bridges the language itself.
<strong>플랫폼이 아닌 언어를 힘으로서:</strong> 이는 엔지니어가 공급업체 종속보다 좋아하는 도구를 선호한다는 더 깊은 추세를 나타냅니다. Flutter와 같은 UI 프레임워크가 뷰를 브리지하고 KMP가 로직을 브리징하는 경우 _Android의 Swift_는 언어 자체를 연결합니다.</li>
</ul>
<p>If Flutter proved you could write <em><strong>UI once, and KMP</strong></em> proved you could share logic Swift on Android proves that even Apple’s crown jewel language can evolve beyond its original walls. It’s a statement: the future of mobile is defined by <em><strong>languages</strong></em> and <em><strong>flexibility</strong></em>, not by corporate boundaries.
Flutter가 <em><strong>UI를 한 번</strong></em> 작성할 수 있다는 것을 증명하고 KMP가 논리를 공유할 수 있음을 증명했다면 Android의 Swift는 Apple의 왕관 보석 언어조차도 원래의 벽을 넘어 진화할 수 있음을 증명합니다. 모바일의 미래는 기업의 경계가 아닌 <em><strong>언어</strong></em>와 <em><strong>유연성</strong></em>에 의해 정의된다는 말입니다.</p>
<h1 id="what-exactly-is-the-working-group-doing">What Exactly Is the Working Group Doing?</h1>
<p>워킹 그룹은 정확히 무엇을 하고 있습니까?</p>
<p>This isn’t a solo dev’s side project it’s a structured, community-backed initiative listed officially on <a href="https://forums.swift.org/t/announcing-the-android-workgroup/80666">Swift.org</a>. The Swift Android Working Group is focused on:
이것은 단독 개발자의 사이드 프로젝트가 아니라 <a href="https://forums.swift.org/t/announcing-the-android-workgroup/80666">공식적으로 Swift.org</a> 에 나열된 구조화된 커뮤니티 지원 이니셔티브입니다. Swift Android 워킹 그룹은 다음에 중점을 두고 있습니다.</p>
<ul>
<li>Adding Android to the <strong>official Swift toolchain</strong>.
<strong>공식 Swift 툴체인</strong>에 Android를 추가합니다.</li>
<li>Improving <strong>Foundation</strong>, <strong>Dispatch</strong>, and <strong>Swift Concurrency</strong> for Android.
Android의 <strong>Foundation</strong>, <strong>Dispatch</strong> 및 <strong>Swift 동시성을</strong> 개선합니다.</li>
<li>Defining supported <strong>Android API levels</strong> and <strong>architectures</strong>.
지원되는 <strong>Android API 수준</strong> 및 <strong>아키텍처</strong>를 정의합니다.</li>
<li>Providing <strong>CI tooling</strong>, Docker images, and Gradle support.
<strong>CI 도구</strong>, Docker 이미지 및 Gradle 지원을 제공합니다.</li>
<li>Documenting <strong>JNI (Java Native Interface)</strong> interop best practices.
<strong>JNI(Java Native Interface)</strong> 상호 운용성 모범 사례를 문서화합니다.</li>
<li>Enhancing <strong>debugging support</strong> (e.g., LLDB on Android).
<strong>디버깅 지원</strong> 향상(예: Android의 LLDB).</li>
<li>Creating onboarding docs and starter examples.
온보딩 문서 및 시작 예제 만들기.</li>
</ul>
<p>The mission is not to <strong>“hack it together”</strong> it’s to make Android feel like a <strong>first-class Swift platform</strong>.
임무는 **“함께 해킹”**하는 것이 아니라 Android가 <strong>일류 Swift 플랫폼</strong>처럼 느껴지도록 하는 것입니다.</p>
<h1 id="what-changes-for-developers">What Changes for Developers?</h1>
<p>개발자를 위한 변경 사항은 무엇입니까?</p>
<p>Here’s what this unlocks for real-world teams:
실제 팀을 위해 잠금 해제되는 기능은 다음과 같습니다.</p>
<ul>
<li>Write <strong>core logic in Swift</strong> and share across Android and iOS.
<strong>Swift로 핵심 로직</strong>을 작성하고 Android 및 iOS에서 공유하세요.</li>
<li>Use <strong>Swift Package Manager (SPM)</strong> to build shared modules.
**SPM(Swift Package Manager)**을 사용하여 공유 모듈을 빌드합니다.</li>
<li>Build platform-specific UI with <strong>Compose</strong> (Android) and <strong>SwiftUI</strong> (iOS).
<strong>Compose</strong>(Android) 및 <strong>SwiftUI</strong>(iOS)를 사용하여 플랫폼별 UI를 빌드합니다.</li>
<li>Avoid duplication of models, parsers, and business rules.
모델, 구문 분석기 및 비즈니스 규칙의 중복을 방지합니다.</li>
<li>Improve test coverage across platforms with shared XCTest logic.
공유 XCTest 로직을 통해 플랫폼 전반에서 테스트 커버리지를 개선합니다.</li>
</ul>
<p>In short, teams could reorganize around shared <em>layers</em> (logic, networking, domain) while customizing UI per platform.
요컨대, 팀은 플랫폼별로 UI를 사용자 지정하면서 공유 계층(로직, 네트워킹, 도메인)<em>을 중심으로</em> 재구성할 수 있습니다.</p>
<h1 id="bridging-swift-with-android-finally-possible">Bridging Swift with Android: Finally Possible</h1>
<p>Swift와 Android의 연결: 마침내 가능했습니다.</p>
<p>This works thanks to <strong>JNI (Java Native Interface)</strong>. Tools like <strong>Skip</strong>, <strong>Readdle’s Gradle plugin</strong>, and the open-source <strong>SwiftJava</strong> project make it possible to:
이것은 <strong>JNI (Java Native Interface)</strong> 덕분에 작동합니다. <strong>Skip</strong>, <strong>Readdle의 Gradle 플러그인</strong> 및 오픈 소스 <strong>SwiftJava</strong> 프로젝트와 같은 도구를 사용하면 다음을 수행할 수 있습니다.</p>
<ul>
<li>Call Android APIs directly from Swift.
Swift에서 직접 Android API를 호출합니다.</li>
<li>Use <code>swift build</code> to compile Swift packages for Android.
<code>swift build</code>를 사용하여 Android용 Swift 패키지를 컴파일합니다.</li>
<li>Import Swift logic into Android Studio via Gradle.
Gradle을 통해 Swift 로직을 Android 스튜디오로 가져옵니다.</li>
<li>Share Swift modules between platforms with SPM.
SPM을 사용하여 플랫폼 간에 Swift 모듈을 공유합니다.</li>
<li>Mix Swift and Kotlin modules as needed.
필요에 따라 Swift 및 Kotlin 모듈을 혼합합니다.</li>
</ul>
<p>The JNI glue code handles the bridge, and some tools automate this setup.
JNI 글루 코드는 브리지를 처리하며 일부 도구는 이 설정을 자동화합니다.</p>
<p>You’re not limited to <strong>“Swift-only”</strong> you can mix and match where it makes sense.
**“Swift 전용”**에만 국한되지 않고 의미가 있는 곳에 믹스 앤 매치할 수 있습니다.</p>
<h1 id="how-well-does-it-work-right-now">How Well Does It Work Right Now?</h1>
<p>지금 얼마나 잘 작동합니까?</p>
<p>Here’s what’s already possible today:
오늘날 이미 가능한 것은 다음과 같습니다.</p>
<ul>
<li><strong>Builds compile:</strong> Tools like <a href="https://github.com/skiptools/skip">Skip</a> allow you to compile Swift code for Android ARM and x86 targets.
<strong>빌드 컴파일:</strong> <a href="https://github.com/skiptools/skip">Skip</a>과 같은 도구를 사용하면 Android ARM 및 x86 대상용 Swift 코드를 컴파일할 수 있습니다.</li>
<li><strong>Apps run:</strong> Hello World apps and logic modules built in Swift <em>do</em> run on emulators and real Android devices.
<strong>앱이 실행:</strong> Swift에 내장된 Hello World 앱 및 로직 모듈은 에뮬레이터 및 실제 Android 기기_에서 실행됩니다_.</li>
<li><strong>XCTest support:</strong> Swift unit tests (including Apple’s Swift Algorithms test suite) have been run successfully on Android devices.
<strong>XCTest 지원:</strong> Swift 단위 테스트(Apple의 Swift 알고리즘 테스트 제품군 포함)가 Android 기기에서 성공적으로 실행되었습니다.</li>
<li><strong>Gradle support:</strong> Readdle’s open-source plugin allows Android Studio to integrate Swift libraries.
<strong>Gradle 지원:</strong> Readdle의 오픈 소스 플러그인을 사용하면 Android 스튜디오에서 Swift 라이브러리를 통합할 수 있습니다.</li>
<li><strong>Shared modules:</strong> Swift packages written for iOS now compile for Android, including reusable business logic.
<strong>공유 모듈:</strong> iOS용으로 작성된 Swift 패키지는 이제 재사용 가능한 비즈니스 로직을 포함하여 Android용으로 컴파일됩니다.</li>
<li><strong>CI and Docker tools:</strong> Community members have published GitHub Actions and Docker setups to streamline cross-compilation.
<strong>CI 및 Docker 도구:</strong> 커뮤니티 구성원은 교차 컴파일을 간소화하기 위해 GitHub Actions 및 Docker 설정을 게시했습니다.</li>
</ul>
<p>Is it perfect? No. But is it real and working? Yes and it’s surprisingly capable even in this early stage.
완벽한가? 아니요. 하지만 그것이 진짜이고 효과가 있습니까? 예, 그리고 이 초기 단계에서도 놀라울 정도로 유능합니다.</p>
<h1 id="whos-using-it-already-누가-이미-사용하고-있습니까">Who’s Using It Already? 누가 이미 사용하고 있습니까?</h1>
<p>While still early-stage, we’re already seeing adoption from:
아직 초기 단계이지만 이미 다음과 같은 채택을 보고 있습니다.</p>
<ul>
<li><strong>Indie developers</strong> exploring leaner cross-platform solutions.
더 간결한 크로스 플랫폼 솔루션을 모색하는 <strong>인디 개발자</strong>.</li>
<li><strong>iOS-first startups</strong> expanding to Android without rewriting logic in Kotlin.
<strong>iOS 우선 스타트업이</strong> Kotlin에서 로직을 다시 작성하지 않고 Android로 확장합니다.</li>
<li><strong>Agencies</strong> building shared Swift SDKs for client apps.
클라이언트 앱을 위한 공유 Swift SDK를 구축하는 <strong>기관.</strong></li>
<li><strong>Open-source contributors</strong> prototyping plugins, SDKs, and documentation.
<strong>오픈 소스 기여자는</strong> 플러그인, SDK 및 문서의 프로토타이핑을 제공합니다.</li>
<li><strong>Vapor/Swift server teams</strong> reusing their Swift models and logic on Android.
<strong>Vapor/Swift 서버 팀은</strong> Android에서 Swift 모델과 로직을 재사용합니다.</li>
</ul>
<p><strong>It’s not mainstream — yet. But it’s moving from “can we?” to “how far can we go?”</strong>
<strong>아직 주류는 아닙니다. 그러나 그것은 “우리가 할 수 있을까?” 에서 “우리가 얼마나 멀리 갈 수 있을까”로 이동하고 있습니다.</strong></p>
<h1 id="the-real-challenges-ahead">The Real Challenges Ahead</h1>
<p>앞으로의 진정한 도전 과제</p>
<p>There are real limitations you should know:
알아야 할 실제 제한 사항이 있습니다.</p>
<ul>
<li><strong>SwiftUI isn’t available</strong> on Android only logic can be shared for now.
<strong>SwiftUI는 Android에서 사용할 수 없으며</strong> 현재로서는 로직만 공유할 수 있습니다.</li>
<li><strong>Tooling is immature</strong> — no official Android Studio integration yet.
<strong>툴링은 아직</strong> 공식 Android 스튜디오 통합이 없습니다.</li>
<li><strong>Debugging is manual</strong> — expect Docker, LLDB, and terminal work.
<strong>디버깅은 수동입니다</strong> — Docker, LLDB 및 터미널 작업을 예상합니다.</li>
<li><strong>Binary size</strong> is large — Swift’s runtime adds tens of MB to APKs.
<strong>바이너리 크기</strong>가 크다 — Swift의 런타임은 APK에 수십 MB를 추가합니다.</li>
<li><strong>JNI bridges</strong> can be tricky and verbose to manage manually.
<strong>JNI 브리지는</strong> 수동으로 관리하기가 까다롭고 장황할 수 있습니다.</li>
<li><strong>Documentation is thin</strong> — you’ll live in GitHub issues and forum threads.
<strong>문서는 얇습니다</strong> — GitHub 이슈와 포럼 스레드에 거주하게 됩니다.</li>
<li><strong>Learning curve</strong> — Android devs must learn Swift, and vice versa.
<strong>학습 곡선</strong> — Android 개발자는 Swift를 배워야 하며 그 반대의 경우도 마찬가지입니다.</li>
</ul>
<p>But remember: Flutter, React Native, and Kotlin Multiplatform all started rough. Swift now has the same chance to grow and with the community’s help, it will.
하지만 Flutter, React Native 및 Kotlin Multiplatform은 모두 힘들게 시작했다는 점을 기억하십시오. 스위프트는 이제 성장할 수 있는 동일한 기회를 갖게 되었으며 커뮤니티의 도움으로 성장할 것입니다.</p>
<h1 id="what-this-means-for-developers">What This Means for Developers</h1>
<p>이것이 개발자에게 의미하는 것</p>
<p>This shift isn’t just technical — it’s <strong>philosophical</strong>.
이러한 변화는 기술적인 것이 아니라 <strong>철학적인</strong> 것입니다.</p>
<ul>
<li>Code once, run everywhere (with proper UI).
한 번 코드를 작성하면 모든 곳에서 실행됩니다(적절한 UI 사용).</li>
<li>Choose your language — not your platform allegiance.
플랫폼 충성도가 아닌 언어를 선택하세요.</li>
<li>Reuse models, logic, tests, and libraries.
모델, 로직, 테스트 및 라이브러리를 재사용합니다.</li>
<li>Empower smaller teams and startups.
소규모 팀과 스타트업의 역량을 강화하세요.</li>
<li>Focus on building great products, not rewriting code twice.
코드를 두 번 다시 작성하지 않고 훌륭한 제품을 만드는 데 집중하세요.</li>
</ul>
<p>In the future, mobile development could become <em><strong>language-first</strong></em> instead of <em><strong>platform-first</strong></em> and Swift is leading that charge.
미래에는 모바일 개발이 <em><strong>플랫폼 우선</strong></em>이 아닌 <em><strong>언어 우선</strong></em>이 될 수 있으며 Swift는 그 책임을 주도하고 있습니다.</p>
<h1 id="how-developers-are-reacting">How Developers Are Reacting</h1>
<p>개발자의 반응</p>
<p>The early buzz is strong:
초기 소문은 강합니다.</p>
<p>Press enter or click to view image in full size</p>
<p><a href="https://miro.medium.com/v2/resize:fit:700/0*nFM2nSgR-kFViGhz"></a></p>
<p>Photo by <a href="https://unsplash.com/@ashtychepe?utm_source=medium&#x26;utm_medium=referral">Adriana Elias</a> on <a href="https://unsplash.com/?utm_source=medium&#x26;utm_medium=referral">Unsplash</a>
님이 촬영 한 사진 <a href="https://unsplash.com/@ashtychepe?utm_source=medium&#x26;utm_medium=referral">아드리아나 엘리아스</a> on <a href="https://unsplash.com/?utm_source=medium&#x26;utm_medium=referral">Unsplash</a></p>
<ul>
<li>Developers are sharing Swift Android demos on GitHub.
개발자들은 GitHub에서 Swift Android 데모를 공유하고 있습니다.</li>
<li>Forum threads are filled with experiment reports, toolchain updates, and test results.
포럼 스레드는 실험 보고서, 도구 체인 업데이트 및 테스트 결과로 가득 차 있습니다.</li>
<li>XCTest on Android surprised many — showing just how far this effort has come.
Android의 XCTest는 이러한 노력이 얼마나 멀리 왔는지 보여주며 많은 사람들을 놀라게 했습니다.</li>
<li>Comments like “I thought this was a meme” and “This could replace KMP for us” are popping up regularly.
“이게 밈인 줄 알았어”, “KMP를 대체할 수 있어”와 같은 댓글이 정기적으로 나오고 있습니다.</li>
</ul>
<p>Momentum is building and it’s happening <strong><em>from the community up</em>.</strong>
추진력이 쌓이고 있으며 <em><strong>이는 지역 사회에서 일어나</strong></em>고 있습니다.</p>
<h1 id="want-to-try-it-yourself">Want to Try It Yourself?</h1>
<p>직접 시도해 보고 싶으신가요?</p>
<p>Here’s how to get started:
시작하는 방법은 다음과 같습니다.</p>
<ul>
<li>Visit the <a href="https://forums.swift.org/t/announcing-the-android-workgroup/80666">Swift Android Working Group</a>.
<a href="https://forums.swift.org/t/announcing-the-android-workgroup/80666">Swift Android 워킹 그룹을</a> 방문하세요.</li>
<li>Use the <a href="https://github.com/skiptools">Skip Swift Android toolchain</a> to build for Android.
<a href="https://github.com/skiptools">Skip Swift Android 툴체인</a>을 사용하여 Android용으로 빌드합니다.</li>
<li>Create a Swift package with <code>swift package init</code>.
<code>swift package init</code>를 사용하여 Swift 패키지를 만듭니다.</li>
<li>Compile for Android using cross-compilation targets.
교차 컴파일 대상을 사용하여 Android용으로 컴파일합니다.</li>
<li>Add JNI bridges with tools like SwiftJava or Skip.
SwiftJava 또는 Skip과 같은 도구를 사용하여 JNI 브리지를 추가합니다.</li>
<li>Push XCTest binaries via ADB and run them on a device.
ADB를 통해 XCTest 바이너리를 푸시하고 장치에서 실행합니다.</li>
<li>Join the Swift Forums and Slack to ask questions and contribute.
Swift 포럼과 Slack에 가입하여 질문하고 기여하세요.</li>
</ul>
<blockquote>
<p><strong>It’s still early but if you’re an explorer, this is gold.</strong>
<strong>아직 이르지만 탐험가라면 이것은 금입니다.</strong></p>
</blockquote>
<h1 id="what-the-future-might-look-like">What the Future Might Look Like</h1>
<p>미래는 어떤 모습일지</p>
<p>Let’s dream a bit: 조금 꿈을 꾸자:</p>
<ul>
<li><strong>SwiftUI for Android:</strong> A declarative UI framework running on both platforms.
<strong>Android용 SwiftUI:</strong> 두 플랫폼 모두에서 실행되는 선언적 UI 프레임워크입니다.</li>
<li><strong>One-click Swift modules:</strong> Tools that build and bundle Swift for Android natively.
<strong>원클릭 Swift 모듈:</strong> Android용 Swift를 기본적으로 빌드하고 번들로 제공하는 도구입니다.</li>
<li><strong>Official toolchains:</strong> Swift.org distributing Android-ready binaries and SDKs.
<strong>공식 도구 체인:</strong> Swift.org Android 지원 바이너리 및 SDK를 배포합니다.</li>
<li><strong>Stack-aligned teams:</strong> All developers writing Swift for backend, iOS, and Android.
<strong>스택 정렬 팀:</strong> 백엔드, iOS 및 Android용 Swift를 작성하는 모든 개발자.</li>
<li><strong>Blazing-fast onboarding:</strong> New devs learn one language, and ship everywhere.
초<strong>고속 온보딩:</strong> 새로운 개발자는 한 가지 언어를 배우고 어디든 배송합니다.</li>
</ul>
<p>It’s early but it’s real. In a few years, we might look back and say, “Remember when Swift was only for iOS?”
이르지만 현실입니다. 몇 년 후에는 “Swift가 iOS 전용이었던 때를 기억하십니까?”</p>
<h1 id="final-thoughts-최종-생각">Final Thoughts 최종 생각</h1>
<p>Swift on Android isn’t just a tech experiment it’s a shift in how we think about mobile development.
Android의 Swift는 단순한 기술 실험이 아니라 모바일 개발에 대한 우리의 생각의 변화입니다.</p>
<p>It’s about efficiency, flexibility, and breaking out of silos. It’s about letting languages not vendors guide how we build. And most of all, it’s about <strong>developer choice</strong>.
효율성, 유연성, 사일로에서 벗어나는 것이 중요합니다. 공급업체가 아닌 언어가 구축 방법을 안내하도록 하는 것입니다. 그리고 무엇보다도 <strong>개발자의 선택</strong>에 관한 것입니다.</p>
<p>If you’re tired of maintaining two separate worlds, tired of rewriting business logic, or just curious about the future — this is your moment to explore.
두 개의 별도 세계를 유지하는 데 지쳤거나, 비즈니스 로직을 다시 작성하는 데 지쳤거나, 미래에 대해 궁금하다면 지금이 탐험할 때입니다.</p>
<p>Try Swift on Android. Watch the space. Contribute to the conversation.
Android에서 Swift를 사용해 보세요. 공간을 지켜보세요. 대화에 기여하십시오.</p>
<p>Because what’s happening now could redefine how we build the apps of tomorrow.
지금 일어나고 있는 일이 미래의 앱을 구축하는 방법을 재정의할 수 있기 때문입니다.</p>
<p>If you found this useful, don’t forget to <strong>follow, share, and drop your thoughts in the comments</strong> let’s shape the future of mobile dev together.
이것이 유용하다고 생각되면 <strong>팔로우하고, 공유하고, 댓글에 생각을 남겨</strong>주는 것을 잊지 마세요. 함께 모바일 개발의 미래를 만들어 갑시다.</p>
<p><strong>If you’re excited about this shift in mobile development, you might also enjoy:</strong>
<strong>모바일 개발의 이러한 변화에 기대가 있다면 다음을 즐길 수도 있습니다.</strong></p>
<ul>
<li><a href="https://medium.com/@sharma-deepak/is-apple-trying-to-kill-flutter-with-ios-26-ca5478e45fde">iOS 26 Just Left Flutter Devs Behind</a>
<a href="https://medium.com/@sharma-deepak/is-apple-trying-to-kill-flutter-with-ios-26-ca5478e45fde">iOS 26은 Flutter 개발자를 뒤처졌습니다.</a></li>
<li><a href="https://medium.com/@sharma-deepak/apple-quietly-broke-the-ai-illusion-and-no-ones-talking-about-it-9a87df4abcfc">Apple Quietly Broke the AI Illusion And No One’s Talking About It</a>
<a href="https://medium.com/@sharma-deepak/apple-quietly-broke-the-ai-illusion-and-no-ones-talking-about-it-9a87df4abcfc">Apple은 AI의 환상을 조용히 깨뜨렸고 아무도 그것에 대해 이야기하지 않습니다.</a></li>
</ul>
<p>#SwiftOnAndroid #SwiftAndroid #CrossPlatformDev #MobileDevelopment #SwiftLanguage #AndroidDev #SwiftCommunity #CrossPlatform2025 #SwiftWorkingGroup #TechTrends2025</p> </article> </div> <script type="module">
      // 목적: index.json에서 현재 글 메타/썸네일을 찾아 상세 화면에 반영한다.
      async function hydrateMeta() {
        try {
          const BASE = import.meta.env.BASE_URL;
          const slug = decodeURIComponent(location.pathname.replace(/.*\/post\//,'').replace(/\/?$/,''));
          const res = await fetch(`${BASE}index.json`);
          const data = await res.json();
          const items = (data && data.items) || [];
          const item = items.find((i) => i.slug === slug);
          if (!item) return;

          const hero = document.getElementById('hero');
          const heroImg = document.getElementById('heroImg');
          const source = document.getElementById('source');
          const cta = document.getElementById('ctaSource');
          if (item.thumbnail && hero && heroImg) {
            heroImg.setAttribute('src', item.thumbnail);
            hero.style.display = 'block';
          }
          if (item.source_url && source && cta) {
            source.setAttribute('href', item.source_url);
            cta.setAttribute('href', item.source_url);
            source.style.display='inline-block';
            cta.style.display='inline-block';
          }
        } catch {}
      }
      hydrateMeta();

      // 복사 버튼 제거됨 — 상단에 원문 보기 버튼만 유지
    </script> </body> </html>